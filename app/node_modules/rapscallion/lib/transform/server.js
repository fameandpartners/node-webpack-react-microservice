"use strict";

var t = require("babel-types");

var _require = require("lodash"),
    flatten = _require.flatten;

var htmlStringEscape = require("../render/escape-html");

var _require2 = require("../symbols"),
    REACT_ID = _require2.REACT_ID;

var _isVanillaDomTag = /^[a-z][a-z0-9\-]*$/;
var isVanillaDomTag = function isVanillaDomTag(tag) {
  return _isVanillaDomTag.test(tag);
};

module.exports = function () {
  return {
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      return parserOpts.plugins.push("jsx");
    },
    visitor: {
      JSXElement: {
        enter: function enter(path) {
          var node = path.node;

          path.replaceWith(isVanillaDomTag(node.openingElement.name.name) ? prerenderDom(node) : prerenderComponent(node));
        }
      },
      ObjectExpression: {
        exit: function exit(path, state) {
          var obj = objectExpressionToObject(path.node);
          if (!obj.__prerendered__) {
            return;
          }
          // Mutating, since this is an exit visitor and it is way easier...
          flattenDomSegments(obj);
          if (path.node.__isHoistable__ && state.opts && state.opts.hoist) {
            path.hoist();
          }
        }
      }
    }
  };
};

var flattenDomSegments = function flattenDomSegments(obj) {
  if (!obj.segments) {
    return;
  }
  obj.segments.elements = compress(flatten(obj.segments.elements.map(function (segment) {
    if (!t.isObjectExpression(segment)) {
      return segment;
    }
    var segmentObj = objectExpressionToObject(segment);
    if (!segmentObj.segments) {
      return segment;
    }
    // This will be an ArrayExpression
    return segmentObj.segments.elements;
  })));
};

// <Component />
var prerenderComponent = function prerenderComponent(node) {
  var children = node.children.map(function (child) {
    if (t.isJSXText(child)) {
      var trimmed = child.value.trim();
      return trimmed && t.stringLiteral(trimmed);
    } else if (t.isJSXExpressionContainer(child)) {
      return child.expression;
    }
    return child;
  }).filter(function (x) {
    return x;
  });

  return buildObjectExpression({
    // React.Children.only may be used in app code to validate inputs to a component.
    // We need to provide the right value here in order for it to be detected as a
    // valid React element.
    //
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/isomorphic/children/onlyChild.js#L32-L36
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/isomorphic/classic/element/ReactElement.js#L376-L380
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/shared/utils/ReactElementSymbol.js#L17-L20
    //
    $$typeof: t.callExpression(t.memberExpression(t.identifier("Symbol"), t.identifier("for")), [t.stringLiteral("react.element")]),
    __prerendered__: t.stringLiteral("component"),
    type: t.identifier(node.openingElement.name.name),
    props: t.objectExpression(getComponentProps(node.openingElement.attributes, children))
  });
};

// <div />
var prerenderDom = function prerenderDom(node) {
  var segments = [];
  pushVanillaVdom(segments, node);

  segments = expressionifyStringSegments(segments);
  segments = compress(segments);

  var objExpr = buildObjectExpression({
    // React.Children.only may be used in app code to validate inputs to a component.
    // We need to provide the right value here in order for it to be detected as a
    // valid React element.
    //
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/isomorphic/children/onlyChild.js#L32-L36
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/isomorphic/classic/element/ReactElement.js#L376-L380
    //   https://github.com/facebook/react/blob/b1b4a2fb252f26fe10d29ba60d85ff89a85ff3ec/src/shared/utils/ReactElementSymbol.js#L17-L20
    //
    $$typeof: t.callExpression(t.memberExpression(t.identifier("Symbol"), t.identifier("for")), [t.stringLiteral("react.element")]),
    __prerendered__: t.stringLiteral("dom"),
    segments: t.arrayExpression(segments)
  });

  objExpr.__isHoistable__ = isHoistable(segments);

  return objExpr;
};

var getComponentProps = function getComponentProps(attributes, children) {
  return attributes.map(function (attr) {
    if (t.isJSXSpreadAttribute(attr)) {
      return t.spreadProperty(attr.argument);
    }

    var name = attr.name,
        value = attr.value;

    return t.objectProperty(t.identifier(name.name), t.isJSXExpressionContainer(value) ? value.expression : value);
  }).concat([t.objectProperty(t.identifier("children"), children.length === 1 ? children[0] : t.arrayExpression(children))]);
};

var pushVanillaVdom = function pushVanillaVdom(segments, node) {
  var openingElement = node.openingElement,
      children = node.children,
      closingElement = node.closingElement;


  segments.push(`<${openingElement.name.name}`);
  pushAttributes(segments, openingElement.attributes);
  if (openingElement.selfClosing) {
    segments.push(`></${openingElement.name.name}>`);
    return;
  }

  segments.push(">");

  children.forEach(function (child) {
    if (t.isJSXText(child)) {
      var trimmed = child.value.trim();
      if (trimmed) {
        segments.push(htmlStringEscape(trimmed));
      }
    } else if (t.isJSXExpressionContainer(child)) {
      segments.push(buildObjectExpression({
        __prerendered__: t.stringLiteral("expression"),
        expression: child.expression
      }));
    } else {
      segments.push(child);
    }
  });

  segments.push(`</${closingElement.name.name}>`);
};

var pushAttributes = function pushAttributes(segments, attrs) {
  attrs.forEach(function (attr) {
    var name = attr.name.name,
        value = attr.value;


    if (!value) {
      // If no value is specified, this is a boolean HTML attribute that is set.
      segments.push(` ${name}`);
    } else if (t.isStringLiteral(value)) {
      // If the value is a string literal, it is pre-renderable.
      segments.push(` ${name}="${value.value}"`);
    } else {
      segments.push(buildObjectExpression({
        __prerendered__: t.stringLiteral("attr"),
        attrObj: buildObjectExpression({
          [name]: value.expression
        })
      }));
    }
  });
  segments.push(
  // This is used by the renderer to insert `data-react-id`s.
  t.numericLiteral(REACT_ID));
};

var compress = function compress(elements) {
  return elements.reduce(function (memo, element) {
    var prevIdx = memo.length - 1;
    var prev = memo[prevIdx];

    if (t.isStringLiteral(prev) && t.isStringLiteral(element)) {
      prev.value += element.value;
    } else {
      memo.push(element);
    }

    return memo;
  }, []);
};

var expressionifyStringSegments = function expressionifyStringSegments(segments) {
  return segments.map(function (segment) {
    return typeof segment === "string" ? t.stringLiteral(segment) : segment;
  });
};

var buildObjectExpression = function buildObjectExpression(obj) {
  return t.objectExpression(Object.keys(obj).map(function (key) {
    return t.objectProperty(t.identifier(key), obj[key]);
  }));
};

var objectExpressionToObject = function objectExpressionToObject(objExpr) {
  var obj = Object.create(null);
  objExpr.properties.forEach(function (property) {
    obj[property.key.name || property.key.value] = property.value;
  });
  return obj;
};

var isHoistable = function isHoistable(arrayElements) {
  return arrayElements.every(function (el) {
    return t.isStringLiteral(el) || t.isNumericLiteral(el) || t.isObjectExpression(el) && el.__isHoistable__;
  });
};