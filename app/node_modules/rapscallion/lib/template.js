"use strict";

var _require = require("lodash/fp"),
    compose = _require.compose,
    filter = _require.filter,
    ident = _require.ident,
    flatten = _require.flatten,
    zip = _require.zip;

var render = require("./render");
var Renderer = require("./renderer");

var _require2 = require("./sequence/common"),
    EXHAUSTED = _require2.EXHAUSTED;

var interlaceTemplateSegments = compose(filter(ident), flatten, zip);

function delegateToRenderer(seq, renderer) {
  var oldNext = seq.next;

  seq.delegate(function () {
    renderer._queueRootNode();

    // Patch the sequence's `next` method.
    seq.next = function () {
      var nextVal = renderer._next();

      if (nextVal === EXHAUSTED) {
        seq.next = oldNext;
        return seq.popFrame() || EXHAUSTED;
      }

      return nextVal;
    };
  });
}

function getSequenceEvent(seq, segment) {
  var segmentType = typeof segment;

  if (segmentType === "string") {
    seq.emit(function () {
      return segment;
    });
  } else if (segmentType === "object" && typeof segment.type === "function") {
    render(seq, segment);
  } else if (segmentType === "function") {
    seq.delegate(function () {
      return getSequenceEvent(seq, segment());
    });
  } else if (segment instanceof Renderer) {
    delegateToRenderer(seq, segment);
  } else {
    throw new Error(`Unknown value in template of type ${typeof segment}: ${segment}`);
  }
}

function template(strings) {
  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  var templateSegments = interlaceTemplateSegments(strings, values);
  var renderer = new Renderer();
  renderer._queueRootNode = function (seq) {
    seq = seq || this.sequence;
    templateSegments.forEach(function (segment) {
      return getSequenceEvent(seq, segment);
    });
  };
  return renderer;
}

module.exports = template;