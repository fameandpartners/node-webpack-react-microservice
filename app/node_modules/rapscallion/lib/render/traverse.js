"use strict";

var _require = require("./context"),
    getChildContext = _require.getChildContext,
    getContext = _require.getContext;

var _require2 = require("./state"),
    syncSetState = _require2.syncSetState;

var htmlStringEscape = require("./escape-html");
var renderAttrs = require("./attrs");

var _require3 = require("../symbols"),
    REACT_EMPTY = _require3.REACT_EMPTY,
    REACT_ID = _require3.REACT_ID,
    REACT_TEXT_START = _require3.REACT_TEXT_START,
    REACT_TEXT_END = _require3.REACT_TEXT_END;

var omittedCloseTags = {
  "area": true,
  "base": true,
  "br": true,
  "col": true,
  "embed": true,
  "hr": true,
  "img": true,
  "input": true,
  "keygen": true,
  "link": true,
  "meta": true,
  "param": true,
  "source": true,
  "track": true,
  "wbr": true
};

var newlineEatingTags = {
  "listing": true,
  "pre": true,
  "textarea": true
};

function renderChildrenArray(_ref) {
  var seq = _ref.seq,
      children = _ref.children,
      context = _ref.context;

  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    if (Array.isArray(child)) {
      renderChildrenArray({
        seq,
        children: child,
        context
      });
    } else if (child !== null && child !== undefined && child !== false) {
      traverse({
        seq,
        node: child,
        context,
        numChildren: children.length
      });
    }
  }
}

function renderChildren(_ref2) {
  var seq = _ref2.seq,
      children = _ref2.children,
      context = _ref2.context,
      parent = _ref2.parent;

  if (children === undefined) {
    return;
  }

  if (Array.isArray(children)) {
    renderChildrenArray({
      seq,
      children,
      context
    });
  } else {
    traverse({
      seq,
      node: children,
      context,
      parent
    });
  }
}

/**
 * Evaluates a plain-jane VDOM node (like a <div>).
 *
 * @param      {Sequence}  seq      Sequence that receives HTML segments.
 * @param      {VDOM}      node     VDOM node to be rendered.
 * @param      {Object}    context  Context for the node's children.
 *
 * @return     {undefined}          No return value.
 */
function renderNode(seq, node, context) {
  seq.emit(function () {
    return `<${node.type}`;
  });
  seq.emit(function () {
    return renderAttrs(node.props, node);
  });
  seq.emit(function () {
    return REACT_ID;
  });
  seq.emit(function () {
    return omittedCloseTags[node.type] ? "/>" : ">";
  });
  if (node.props.dangerouslySetInnerHTML) {
    seq.emit(function () {
      return node.props.dangerouslySetInnerHTML.__html || "";
    });
  } else if (node.props.children !== null) {
    if (node.type === "textarea" && node.props.value) {
      seq.emit(function () {
        return node.props.value;
      });
    }

    seq.delegate(function () {
      return renderChildren({
        seq,
        context,
        children: node.props.children,
        parent: node
      });
    });
  }
  if (!omittedCloseTags[node.type]) {
    seq.emit(function () {
      return `</${node.type}>`;
    });
  }
}

/**
 * Prior to being rendered, React components are represented in the same
 * way as true HTML DOM elements.  This function evaluates the component
 * and traverses through its rendered elements.
 *
 * @param      {Sequence}  seq      Sequence that receives HTML segments.
 * @param      {VDOM}      node     VOM node (of a component).
 * @param      {Object}    context  React context.
 *
 * @return     {undefined}          No return value.
 */
function evalComponent(seq, node, context) {
  var Component = node.type;

  var componentContext = getContext(Component, context);
  var instance = constructComponent(Component, node.props, componentContext);
  var renderedElement = renderComponentInstance(instance, node.props, componentContext);

  var childContext = getChildContext(Component, instance, context);
  traverse({
    seq,
    node: renderedElement,
    context: childContext
  });
}

function constructComponent(Component, props, context) {
  if (!(Component.prototype && Component.prototype.isReactComponent)) {
    // eslint-disable-next-line new-cap
    return Component(props, context);
  } else {
    return new Component(props, context);
  }
}

function renderComponentInstance(instance, props, context) {
  var renderedElement = void 0;
  // Stateless functional components return rendered element directly rather than component instance
  if (instance === null || typeof instance.render !== "function") {
    renderedElement = instance;
  } else {
    instance.props = props;
    instance.context = context;
    if (typeof instance.componentWillMount === "function") {
      instance.setState = syncSetState;
      instance.componentWillMount();
    }
    renderedElement = instance.render();
  }
  return renderedElement;
}

function evalSegment(seq, segment, context) {
  if (typeof segment === "string") {
    seq.emit(function () {
      return segment;
    });
  } else if (segment === REACT_ID) {
    seq.emit(function () {
      return REACT_ID;
    });
  } else if (segment.__prerendered__ === "attr") {
    seq.emit(function () {
      return renderAttrs(segment.attrObj);
    });
  } else if (segment.__prerendered__ === "expression") {
    if (typeof segment.expression === "string") {
      seq.emit(function () {
        return htmlStringEscape(segment.expression);
      });
    } else if (Array.isArray(segment.expression)) {
      segment.expression.forEach(function (subsegment) {
        return traverse({
          seq,
          node: subsegment,
          context
        });
      });
    } else {
      traverse({
        seq,
        node: segment.expression,
        context
      });
    }
  } else {
    traverse({
      seq,
      node: segment,
      context
    });
  }
}

function evalPreRendered(seq, node, context) {
  var prerenderType = node.__prerendered__;
  if (prerenderType === "dom") {
    node.segments.forEach(function (segment) {
      if (Array.isArray(segment)) {
        segment.forEach(function (subsegment) {
          return evalSegment(seq, subsegment, context);
        });
      } else {
        evalSegment(seq, segment, context);
      }
    });
  } else if (prerenderType === "attr") {
    var name = node.name,
        value = node.value;

    if (value) {
      seq.emit(function () {
        return ` ${name}="${value}"`;
      });
    }
  } else if (prerenderType === "component") {
    evalComponent(seq, node, context);
  }
}

function emitEmpty(seq) {
  seq.emit(function () {
    return REACT_EMPTY;
  });
}

function emitText(_ref3) {
  var seq = _ref3.seq,
      text = _ref3.text,
      numChildren = _ref3.numChildren,
      isNewlineEatingTag = _ref3.isNewlineEatingTag;

  var hasSiblings = Boolean(numChildren);

  if (hasSiblings) {
    seq.emit(function () {
      return REACT_TEXT_START;
    });
  }

  if (isNewlineEatingTag && text.charAt(0) === "\n") {
    text = `\n${text}`;
  }

  seq.emit(function () {
    return text;
  });

  if (hasSiblings) {
    seq.emit(function () {
      return REACT_TEXT_END;
    });
  }
}

function shouldEmitByType(seq, node) {
  return node !== undefined && node !== false && node !== true;
}

/**
 * This function will recursively traverse the VDOM tree, emitting HTML segments
 * to the provided sequence.
 *
 * @param      {Sequence}  seq          Sequence that receives HTML segments.
 * @param      {VDOM}      node         Root VDOM node.
 * @param      {Object}    context      React context.
 * @param      {Number}    numChildren  number of children the parent node has
 *
 * @return     {undefined}          No return value.
 */
// eslint-disable-next-line max-statements
function traverse(_ref4) {
  var seq = _ref4.seq,
      node = _ref4.node,
      context = _ref4.context,
      numChildren = _ref4.numChildren,
      parent = _ref4.parent;

  if (!shouldEmitByType(seq, node)) {
    return;
  }

  if (node === null) {
    emitEmpty(seq);
    return;
  }

  switch (typeof node) {
    case "string":
      {
        // Text node.
        emitText({
          seq,
          text: htmlStringEscape(node),
          numChildren,
          isNewlineEatingTag: Boolean(parent && newlineEatingTags[parent.type])
        });

        return;
      }
    case "number":
      {
        emitText({
          seq,
          text: node.toString(),
          numChildren
        });

        return;
      }
    case "object":
      {
        if (node.__prerendered__) {
          evalPreRendered(seq, node, context);
          return;
        } else if (typeof node.type === "string") {
          // Plain-jane DOM element, not a React component.
          seq.delegateCached(node, function (_seq, _node) {
            return renderNode(_seq, _node, context);
          });
          return;
        } else if (node.$$typeof) {
          // React component.
          seq.delegateCached(node, function (_seq, _node) {
            return evalComponent(_seq, _node, context);
          });
          return;
        }
      }
  }

  throw new TypeError(`Unknown node of type: ${node.type}`);
}

module.exports = traverse;