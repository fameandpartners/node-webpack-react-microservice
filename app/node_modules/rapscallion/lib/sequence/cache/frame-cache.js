"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Promise = require("bluebird");

var _require = require("../common"),
    EXHAUSTED = _require.EXHAUSTED;

var _compress = require("../compress");

var FrameCache = function () {
  function FrameCache(onComplete, seq) {
    _classCallCheck(this, FrameCache);

    this.onComplete = onComplete;
    this.buffer = [];
    this.seq = seq;
  }

  _createClass(FrameCache, [{
    key: "fork",
    value: function fork() {
      return new FrameCacheIterator(this.getNextFn());
    }
  }, {
    key: "compress",
    value: function compress() {
      // compress the buffer (all sub-promises should be filtered out, so its serializable)
      // invoke the callback to set the value onCompress
      this.onComplete(_compress(this.buffer));
    }
  }, {
    key: "getNextFn",
    value: function getNextFn() {
      var _this = this;

      // Close over reference so that FrameCacheIterators can refer to the buffer after
      // it has been compressed, but still allow it to be garbage collected once all
      // consumers have finished with it.
      var buffer = this.buffer;

      var getNextVal = function getNextVal(val) {
        var nextVal = val || _this.seq.next();

        if (nextVal instanceof Promise) {
          return nextVal.then(getNextVal);
        }

        buffer.push(nextVal);
        // Once the FrameCache's sequence has been exhausted, it is safe to compress
        // the buffer and set the value via the specified cache strategy.  Other
        // iterators will still have access to the uncompressed buffer via a closure.
        if (nextVal === EXHAUSTED) {
          _this.compress();
        }

        return nextVal;
      };

      return function (idx) {
        return idx === buffer.length ? getNextVal() : _this.buffer[idx];
      };
    }
  }]);

  return FrameCache;
}();

var FrameCacheIterator = function () {
  function FrameCacheIterator(nextFn) {
    var _this2 = this;

    _classCallCheck(this, FrameCacheIterator);

    this.idx = 0;
    this.next = function () {
      return nextFn(_this2.idx++);
    };
  }

  // Patch the Sequence's `next` method to iterate over the FrameCache's sequence.
  // Once all sequence events have been consumed, restore the original method.


  _createClass(FrameCacheIterator, [{
    key: "patch",
    value: function patch(seq) {
      var _this3 = this;

      var oldNext = seq.next;

      seq.next = function () {
        var nextVal = _this3.next();

        if (nextVal === EXHAUSTED) {
          seq.next = oldNext;
          return seq.popFrame() || EXHAUSTED;
        }

        return nextVal;
      };
    }
  }]);

  return FrameCacheIterator;
}();

module.exports = {
  FrameCache,
  FrameCacheIterator
};