"use strict";

var _require = require("../frame-cache"),
    FrameCache = _require.FrameCache;

var cache = Object.create(null);

// eslint-disable-next-line max-params
function getCachedFrame(node, cacheKey, delegateFn, Sequence) {
  var cacheEntry = cache[cacheKey];

  if (cacheEntry && cacheEntry.compressed) {
    // Once a cache entry has been completely evaluated and compressed, it is no longer
    // necessary to patch the original sequence.  Instead, simply emit the cached
    // segments onto the original sequence.
    return {
      patch: function patch(originalSequence) {
        cacheEntry.segments.forEach(function (segment) {
          return originalSequence.emit(function () {
            return segment;
          });
        });
      }
    };
  }

  if (!cacheEntry) {
    var onCompress = function onCompress(buffer) {
      cache[cacheKey] = {
        compressed: true,
        // Remove the EXHAUSTED symbol from the end;
        segments: buffer.slice(0, -1)
      };
    };

    var seq = new Sequence();
    delegateFn(seq, node);

    cacheEntry = cache[cacheKey] = new FrameCache(onCompress, seq);
  }

  return cacheEntry.fork();
}

module.exports = function () {
  return getCachedFrame;
};