"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Promise = require("bluebird");

var _require = require("lodash"),
    assign = _require.assign,
    omit = _require.omit;

var _require2 = require("./common"),
    EXHAUSTED = _require2.EXHAUSTED;

var _require3 = require("./cache"),
    getFrameCache = _require3.getFrameCache;

var Sequence = function () {
  function Sequence() {
    _classCallCheck(this, Sequence);

    this.stack = [];

    this.next = this.next.bind(this);

    // Frame-specific state:
    this.eventGenQueue = [];
    this.delegates = Object.create(null);
    this.cursor = 0;
  }

  _createClass(Sequence, [{
    key: "pushFrame",
    value: function pushFrame(delegate) {
      // Save state attached to parent frame.
      this.stack.push({
        eventGenQueue: this.eventGenQueue,
        delegates: this.delegates,
        cursor: this.cursor
      });

      // Initialize the new frame.
      this.eventGenQueue = [];
      this.delegates = Object.create(null);
      this.cursor = 0;

      // Let the delegate do its thing...
      return delegate();
    }
  }, {
    key: "popFrame",
    value: function popFrame() {
      var parentFrame = this.stack.pop();
      if (parentFrame) {
        var eventGenQueue = parentFrame.eventGenQueue,
            delegates = parentFrame.delegates,
            cursor = parentFrame.cursor;

        this.eventGenQueue = eventGenQueue;
        this.delegates = delegates;
        this.cursor = cursor;

        return this.next();
      }
      return null;
    }
  }, {
    key: "emit",
    value: function emit(fn) {
      this.eventGenQueue.push(fn);
    }
  }, {
    key: "delegate",
    value: function delegate(delegateFn) {
      this.delegates[this.eventGenQueue.length] = true;
      this.eventGenQueue.push(delegateFn);
    }
  }, {
    key: "delegateCached",
    value: function delegateCached(node, delegateFn) {
      var _this = this;

      var cacheKey = node.props && node.props.cacheKey || node.attrObj && node.attrObj.cacheKey;

      if (!cacheKey) {
        this.delegate(function () {
          return delegateFn(_this, node);
        });
        return;
      }

      this.delegates[this.eventGenQueue.length] = true;

      var _node = assign({}, node, {
        props: omit(node.props, ["cacheKey"])
      });

      var frameIterator = getFrameCache(_node, cacheKey, delegateFn, Sequence);

      // The callback will be invoked by `pushFrame`, followed by a call to `next`..
      this.eventGenQueue.push(function () {
        return typeof frameIterator.then === "function" ? frameIterator.then(function (_frameIterator) {
          return _frameIterator.patch(_this);
        }) : frameIterator.patch(_this);
      });
    }

    /**
     * Return a value from this instance's event queue.  If the instance
     * is currently delegating its event generation, return the next
     * value from the delegate.  If the event-generator returns a new
     * Sequence, delegate event-generation to that sequence until it has
     * been exhausted.
     *
     * @return     {Any|EXHAUSTED}  Any value, or the EXHAUSTED symbol.
     */

  }, {
    key: "next",
    value: function next() {
      var _this2 = this;

      var nextIsDelegate = this.delegates[this.cursor];
      var nextFn = this.eventGenQueue[this.cursor++];
      if (!nextFn) {
        var frame = this.popFrame();
        if (frame) {
          return Promise.resolve(frame);
        }

        return EXHAUSTED;
      }

      if (nextIsDelegate) {
        return Promise.resolve().then(function () {
          var frame = _this2.pushFrame(nextFn);
          return frame;
        }).then(function () {
          return _this2.next();
        });
      }

      return Promise.resolve().then(nextFn);
    }
  }]);

  return Sequence;
}();

module.exports = {
  Sequence,
  sequence: function sequence() {
    return new Sequence();
  }
};