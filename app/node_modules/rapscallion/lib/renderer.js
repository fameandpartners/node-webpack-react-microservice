"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require("lodash"),
    isInteger = _require.isInteger;

var adler32 = require("./adler32");

var render = require("./render");

var _require2 = require("./sequence"),
    sequence = _require2.sequence;

var _toPromise = require("./consumers/promise");
var toNodeStream = require("./consumers/node-stream");

var _require3 = require("./symbols"),
    REACT_EMPTY = _require3.REACT_EMPTY,
    REACT_ID = _require3.REACT_ID,
    REACT_TEXT_START = _require3.REACT_TEXT_START,
    REACT_TEXT_END = _require3.REACT_TEXT_END;

var REACT_ID_START = 1;

/**
 * A friendly wrapper around rendering operations.  The public API
 * is documented in the README.
 */

var Renderer = function () {
  function Renderer(vdomNode, seq) {
    _classCallCheck(this, Renderer);

    this.sequence = seq || sequence();
    this.vdomNode = vdomNode;

    this.batchSize = 100;
    this.dataReactAttrs = true;
    this._stream = null;
    this.reactIdIdx = REACT_ID_START;
    this._checksum = undefined;
  }

  _createClass(Renderer, [{
    key: "_queueRootNode",
    value: function _queueRootNode(seq) {
      render(seq || this.sequence, this.vdomNode);
    }
  }, {
    key: "_rootVal",
    value: function _rootVal() {
      var val = void 0;

      if (this.dataReactAttrs) {
        val = this.reactIdIdx === REACT_ID_START ? ` data-reactroot="" data-reactid="${this.reactIdIdx}"` : ` data-reactid="${this.reactIdIdx}"`;

        this.reactIdIdx++;

        return val;
      }

      return val;
    }
  }, {
    key: "_emptyVal",
    value: function _emptyVal() {
      var val = void 0;

      if (this.dataReactAttrs) {
        val = `<!-- react-empty: ${this.reactIdIdx} -->`;

        this.reactIdIdx++;
      }

      return val;
    }
  }, {
    key: "_textStart",
    value: function _textStart() {
      var val = void 0;

      if (this.dataReactAttrs) {
        val = `<!-- react-text: ${this.reactIdIdx} -->`;

        this.reactIdIdx++;
      }

      return val;
    }
  }, {
    key: "_textEnd",
    value: function _textEnd() {
      var val = void 0;

      if (this.dataReactAttrs) {
        val = "<!-- /react-text -->";
      }

      return val;
    }
  }, {
    key: "_next",
    value: function _next() {
      var _this = this;

      var next = this.sequence.next();

      if (!(next && next.then)) {
        return next;
      }

      return next.then(function (nextVal) {
        if (nextVal === REACT_ID) {
          nextVal = _this._rootVal();
        } else if (nextVal === REACT_EMPTY) {
          nextVal = _this._emptyVal();
        } else if (nextVal === REACT_TEXT_START) {
          nextVal = _this._textStart();
        } else if (nextVal === REACT_TEXT_END) {
          nextVal = _this._textEnd();
        }

        if (!nextVal) {
          return "";
        }

        _this._checksum = adler32(nextVal, _this._checksum);

        return nextVal;
      });
    }
  }, {
    key: "toPromise",
    value: function toPromise() {
      this._queueRootNode();
      return _toPromise(this);
    }
  }, {
    key: "toStream",
    value: function toStream() {
      this._queueRootNode();
      return toNodeStream(this);
    }
  }, {
    key: "checksum",
    value: function checksum() {
      if (!this._checksum) {
        throw new Error("checksum method must be invoked after rendering has completed.");
      }
      return this._checksum.toString();
    }
  }, {
    key: "includeDataReactAttrs",
    value: function includeDataReactAttrs(yesNo) {
      this.dataReactAttrs = yesNo;
      return this;
    }
  }, {
    key: "tuneAsynchronicity",
    value: function tuneAsynchronicity(batchSize) {
      if (!isInteger(batchSize) || batchSize < 1) {
        throw new RangeError("Asynchronicity must be an integer greater than or equal to 1.");
      }
      this.batchSize = batchSize;
      return this;
    }
  }]);

  return Renderer;
}();

module.exports = Renderer;